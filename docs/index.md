# BioCCP
## Intro
 
BioCCP.jl applies the Coupon Collector Problem to **combinatorial biotechnology**, in particular to aid (expected) **minimum sample size** determination for screening experiments. 

**Modular designs** are considered, created by randomly combining `r` modules from a set of `n`available modules (sampling with replacement). The module probabilities during the generation of the designs are specified by a probability/abundance vector `p_vec`. Depending on how many complete sets of modules one wants to observe, parameter `m` can be increased from its default value of 1 to a higher value. 

For a specific combinatorial design set-up of interest, a report with results regarding (expected) minimum sample sizes can be easily retrieved by using the provided Pluto notebook.

## Functions

<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/></head><body><div id="documenter"><nav class="docs-sidebar">  <article class="docstring"><header><a class="docstring-binding" id="BioCCP.expectation_minsamplesize" href="#BioCCP.expectation_minsamplesize"><code><strong>BioCCP.expectation_minsamplesize</strong></code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expectation_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)</code></pre><p>Calculates the expected minimum number of designs <code>E[T]</code>  to observe each module at least <code>m</code> times.</p><ul><li><code>n</code>: number of modules in the design space</li><li><code>p_vec</code>: vector with the probabilities or abundances of the different modules</li><li><code>m</code>: number of times each module has to be observed in the sampled set of designs </li><li><code>r</code>: number of modules per design</li><li>normalize: if true, normalize <code>p_vec</code></li></ul><p><small>References</small></p><ul><li>Doumas, A. V., &amp; Papanicolaou, V. G. (2016). The coupon collector’s problem revisited: generalizing the double Dixie cup problem of Newman and Shepp. ESAIM: Probability and Statistics, 20, 367-399.</li><li>Boneh, A., &amp; Hofri, M. (1997). The coupon-collector problem revisited—a survey of engineering problems and computational methods. Stochastic Models, 13(1), 39-66.</li></ul><p><small>Examples</small></p><pre><code class="language-julia-repl">julia&gt; n = 100
julia&gt; expectation_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)
519.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BioCCP.std_minsamplesize" href="#BioCCP.std_minsamplesize"><code><strong>BioCCP.std_minsamplesize</strong></code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">std_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)</code></pre><p>Calculates the standard deviation on the minimum number of designs to observe each module at least <code>m</code> times.</p><ul><li><code>n</code>: number of modules in the design space</li><li><code>p_vec</code>: vector with the probabilities or abundances of the different modules</li><li><code>m</code>: number of times each module has to be observed in the sampled set of designs </li><li><code>r</code>: number of modules per design</li><li>normalize: if true, normalize <code>p_vec</code></li></ul><p><small>Examples</small></p><pre><code class="language-julia-repl">julia&gt; n = 100
julia&gt; std_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)
126.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BioCCP.success_probability" href="#BioCCP.success_probability"><code><strong>BioCCP.success_probability</strong></code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">success_probability(n, t; p_vec = ones(n), m = 1, r = 1, normalize = true)</code></pre><p>Calculates the success probability <code>F(t) = P(T ≤ t)</code> or the probability that the minimum number of designs <code>T</code> to see each module at least <code>m</code> times is smaller than or equal to <code>t</code>.</p><ul><li><code>n</code>: number of modules in design space</li><li><code>t</code>: sample size/number of designs for which to calculate the success probability </li><li><code>p_vec</code>: vector with the probabilities or abundances of the different modules</li><li><code>m</code>: number of times each module has to be observed in the sampled set of designs </li><li><code>r</code>: number of modules per design</li><li>normalize: if true, normalize <code>p_vec</code></li></ul><p><small>References</small></p><ul><li>Boneh, A., &amp; Hofri, M. (1997). The coupon-collector problem revisited—a survey of engineering problems and computational methods. Stochastic Models, 13(1), 39-66.</li></ul><p><small>Examples</small></p><pre><code class="language-julia-repl">julia&gt; n = 100
julia&gt; t = 600
julia&gt; success_probability(n, t; p_vec = ones(n), m = 1, r = 1, normalize = true)
0.7802171997092149</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BioCCP.expectation_fraction_collected" href="#BioCCP.expectation_fraction_collected"><code><strong>BioCCP.expectation_fraction_collected</strong></code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expectation_fraction_collected(n, t; p_vec = ones(n), r = 1, normalize=true)</code></pre><p>Calculates the expected fraction of all modules observed after collecting <code>t</code>designs.</p><ul><li><code>n</code>: number of modules in design space</li><li><code>t</code>: sample size/number of designs for which to calculate the expected fraction of modules observed</li><li><code>p_vec</code>: vector with the probabilities or abundances of the different modules </li><li><code>r</code>: number of modules per design</li><li>normalize: if true, normalize <code>p_vec</code></li></ul><p><small>References</small></p><ul><li>Boneh, A., &amp; Hofri, M. (1997). The coupon-collector problem revisited—a survey of engineering problems and computational methods. Stochastic Models, 13(1), 39-66.</li></ul><p><small>Examples</small></p><pre><code class="language-julia-repl">julia&gt; n = 100
julia&gt; t = 200
julia&gt; expectation_fraction_collected(n, t; p_vec = ones(n), r = 1, normalize=true)
0.8660203251420364</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BioCCP.prob_occurrence_module" href="#BioCCP.prob_occurrence_module"><code><strong>BioCCP.prob_occurrence_module</strong></code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prob_occurrence_module(p, t, j)</code></pre><p>Calculates probability that specific module with module probability <code>p</code>  has occurred <code>j</code> times after collecting <code>t</code> designs.</p><p>Sampling of modules are assumed to be independent Poisson processes.</p><ul><li><code>p</code>: module probability</li><li><code>t</code>: sample size/number of designs </li><li><code>j</code>: number of occurrence </li></ul><p><small>References</small></p><ul><li>Boneh, A., &amp; Hofri, M. (1997). The coupon-collector problem revisited—a survey of engineering problems and computational methods. Stochastic Models, 13(1), 39-66.</li></ul><p><small>Examples</small></p><pre><code class="language-julia-repl">julia&gt; p = 0.005
julia&gt; t = 500
julia&gt; t = 2
julia&gt; prob_occurrence_module(p, t, j)
0.25651562069968376</code></pre> 


 


