# BioCCP
## Intro
 
BioCCP.jl applies the Coupon Collector's Problem to **combinatorial biotechnology**, in particular to aid **minimum sample size** determination of screening experiments. 

**Modular designs** are considered, created by randomly combining `r` modules from a set of `n`available modules. The module probabilities during the generation of the designs are specified by a probability/abundance vector `p_vec`. Depending on how many complete sets of modules one wants to observe, parameter `m` can be increased from its default value of 1 to a higher value. 

For a specific combinatorial design set-up of interest, a report with results regarding minimum sample sizes can be easily retrieved by using the provided Pluto notebook.

## Functions

<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BioCCP · BioCCP</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar">  <article class="docstring"><header><a class="docstring-binding" id="BioCCP.expectation_minsamplesize" href="#BioCCP.expectation_minsamplesize"><code>BioCCP.expectation_minsamplesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expectation_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)</code></pre><p>Calculates the expected number of designs needed <code>E[T]</code>,  the minimum sample size to observe each module at least <code>m</code> times.</p><ul><li><code>n</code>: number of modules in the design space</li><li><code>p_vec</code>: vector with the probabilities or abundances of the different modules</li><li><code>m</code>: number of complete sets of modules that need to be collected </li><li><code>r</code>: number of modules per design</li><li>normalize: if true, normalize <code>p_vec</code></li></ul><p>References:</p><ul><li>Doumas, A. V., &amp; Papanicolaou, V. G. (2016). The coupon collector’s problem revisited: generalizing the double Dixie cup problem of Newman and Shepp. ESAIM: Probability and Statistics, 20, 367-399.</li><li>Boneh, A., &amp; Hofri, M. (1997). The coupon-collector problem revisited—a survey of engineering problems and computational methods. Stochastic Models, 13(1), 39-66.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; n = 100
julia&gt; expectation_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)
519.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BioCCP.std_minsamplesize" href="#BioCCP.std_minsamplesize"><code>BioCCP.std_minsamplesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">std_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)</code></pre><p>Calculates the standard deviation on the number of designs needed <code>std[T]</code>,  the standard deviation on the minimum sample size to observe each module at least <code>m</code> times.</p><ul><li><code>n</code>: number of modules in the design space</li><li><code>p_vec</code>: vector with the probabilities or abundances of the different modules</li><li><code>m</code>: number of complete sets of modules that need to be collected </li><li><code>r</code>: number of modules per design</li><li>normalize: if true, normalize <code>p_vec</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; n = 100
julia&gt; std_minsamplesize(n; p_vec = ones(n), m = 1, r = 1, normalize = true)
126.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BioCCP.success_probability" href="#BioCCP.success_probability"><code>BioCCP.success_probability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">success_probability(n, t; p_vec = ones(n), m = 1, r = 1, normalize = true)</code></pre><p>Calculates the success probability <code>F(t) = P(T &lt; t)</code> or the chance that  the required number of designs to see each module at least <code>m</code> times is smaller than <code>t</code>.</p><ul><li><code>n</code>: number of modules in design space</li><li><code>t</code>: sample size/number of designs for which to calculate the success probability </li><li><code>p_vec</code>: vector with the probabilities or abundances of the different modules</li><li><code>m</code>: number of complete sets of modules that need to be collected </li><li><code>r</code>: number of modules per design</li><li>normalize: if true, normalize <code>p_vec</code></li></ul><p>References:</p><ul><li>Boneh, A., &amp; Hofri, M. (1997). The coupon-collector problem revisited—a survey of engineering problems and computational methods. Stochastic Models, 13(1), 39-66.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; n = 100
julia&gt; t = 600
julia&gt; success_probability(n, t; p_vec = ones(n), m = 1, r = 1, normalize = true)
0.7802171997092149</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BioCCP.expectation_fraction_collected" href="#BioCCP.expectation_fraction_collected"><code>BioCCP.expectation_fraction_collected</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expectation_fraction_collected(n, t; p_vec = ones(n), r = 1, normalize=true)</code></pre><p>Calculates the expected fraction of all modules observed after collecting <code>t</code>designs.</p><ul><li><code>n</code>: number of modules in design space</li><li><code>t</code>: sample size/number of designs for which to calculate the expected fraction of modules observed</li><li><code>p_vec</code>: vector with the probabilities or abundances of the different modules </li><li><code>r</code>: number of modules per design</li><li>normalize: if true, normalize <code>p_vec</code></li></ul><p>References:</p><ul><li>Boneh, A., &amp; Hofri, M. (1997). The coupon-collector problem revisited—a survey of engineering problems and computational methods. Stochastic Models, 13(1), 39-66.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; n = 100
julia&gt; t = 200
julia&gt; expectation_fraction_collected(n, t; p_vec = ones(n), r = 1, normalize=true)
0.8660203251420364</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BioCCP.prob_occurence_module" href="#BioCCP.prob_occurence_module"><code>BioCCP.prob_occurence_module</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prob_occurence_module(p, t, j)</code></pre><p>Calculates probability that specific module with module probability <code>p</code>  has occured <code>j</code> times after collecting <code>t</code> designs.</p><p>Sampling of modules are assumed to be independent Poisson processes.</p><ul><li><code>p</code>: module probaility</li><li><code>t</code>: sample size/number of designs </li><li><code>j</code>: number of occurence </li></ul><p>References:</p><ul><li>Boneh, A., &amp; Hofri, M. (1997). The coupon-collector problem revisited—a survey of engineering problems and computational methods. Stochastic Models, 13(1), 39-66.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; p = 0.005
julia&gt; t = 500
julia&gt; t = 2
julia&gt; prob_occurence_module(p, t, j)
0.25651562069968376</code></pre></div></section></article> html>



## References
- Doumas, A. V., & Papanicolaou, V. G. (2016). *The coupon collector’s problem revisited: generalizing the double Dixie cup problem of Newman and Shepp.* ESAIM: Probability and Statistics, 20, 367-399.
- Boneh, A., & Hofri, M. (1997). *The coupon-collector problem revisited—a survey of engineering problems and computational methods.* Stochastic Models, 13(1), 39-66.




